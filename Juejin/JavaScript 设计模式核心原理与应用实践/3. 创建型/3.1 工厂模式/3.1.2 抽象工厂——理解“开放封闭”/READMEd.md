> 构造器：解决的是多个对象实例的问题
>
> 简单工厂：解决的是多个类的问题
>
> 抽象工厂：解决的是多个工厂的问题

> 1. 抽象工厂在很长一段时间里，都被认为是 Java/C++ 这类语言的专利
> 2. Java/C++ 是**强类型的静态语言**，用这些语言创建对象时，需要时刻关注类型之间的解耦，以便该对象日后可以表现出**多态性**
> 3. JavaScript 作为一种弱类型的语言，具有天然的多态性，**好像**压根不需要考虑类型解耦问题——目前的 JavaScript 语法里**确实不支持抽象类的直接实现**，只能凭借模拟去还原抽象类

## 一个不简单的简单工厂引发的命案

1. 上一节中，我们把 Boss 这个角色和普通员工塞进了一个工厂
   （1）Boss 和基层员工在职能上差别上还是挺大的，需要在员工系统里进行表现——需要对某一群体的对象进行单独的逻辑处理（员工绩效评估的打分入口以及其他许多操作，只有管理层可以执行）
   （2）修改 Factory 的函数体、增加管理层相关的判断和处理逻辑？
   		——单从功能实现上来说，没问题
   		——但公司不仅能金只有这两类人，还有外包同学、保安，他们的权限和职能都存在着质的差别：因此，如果每考虑到一个新的员工群体，就回去修改一次 Factory 的函数体，这样做就糟糕透了

> 1. 首先，Factory 会变得异常庞大——庞大到每次添加的时候都不敢下手，生怕自己万一写出一个 Bug，就会导致 Factory 的崩坏，进而摧毁整个系统
> 2. 其次，坑死了你的队友——Factory 的逻辑过于繁杂和混乱，没人敢维护它
> 3. 最后，还连带坑了测试同学——每次新加一个工种，都不得不对整个 Factory 的逻辑进行回归（因为新加工种这个改变你是在 Factory 内部原地发生的）
>
> **这一切悲剧的根源只有一个——没有遵守开放封闭原则**

> 开放封闭原则：对拓展开放，对修改封闭——即软件实体（类、模块、函数）可以扩展，但是不可修改——**修改 Factory 函数体的操作实际上就是在修改，而不是在扩展**

## 抽象工厂模式

1. 智能手机的基本组成 = 操作系统（Operating System，OS）+ 硬件（HardWare）

2. 工厂必须既准备好了操作系统，也准备好了硬件，才能实现手机的量产——操作系统和硬件背后存在不同的厂商，但现在**并不知道下一个生产线到底具体想生产一台什么样的手机**，只知道手机必须有这两部分组成，所以先用一个**抽象类**来约定住这台手机的基本组成：

   ```js
   class MobilePhoneFactory {
       // 提供操作系统的接口
       createOS() {
           throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！")
       }
       // 提供硬件的接口
       createHardWare() {
           throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！")
       }
   }
   ```

3. **抽象工厂（AbstractFactory）不干活，具体工厂（ConcreteFactory）来干活！**——当明确了生产方案，明确某一条手机生产流水线具体要生产什么样的手机之后，就可以**化抽象为具体**

4. 想要一个专门生产 Android 系统 + 高通硬件的手机的生产线，给这类手机型号起名叫 FakeStar：

   ```js
   class FakeStarFactory extends MobilePhoneFactory {
       createOS() {
           // 提供安卓系统实例
           return new AndroidOS()
       }
       createHardWare() {
           // 提供高通硬件实例
           return new QualcommHardWare()
       }
   }
   ```

   