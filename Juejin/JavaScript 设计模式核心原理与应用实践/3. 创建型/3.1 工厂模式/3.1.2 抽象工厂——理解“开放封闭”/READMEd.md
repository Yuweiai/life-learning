> 构造器：解决的是多个对象实例的问题
>
> 简单工厂：解决的是多个类的问题
>
> 抽象工厂：解决的是多个工厂的问题

> 1. 抽象工厂在很长一段时间里，都被认为是 Java/C++ 这类语言的专利
> 2. Java/C++ 是**强类型的静态语言**，用这些语言创建对象时，需要时刻关注类型之间的解耦，以便该对象日后可以表现出**多态性**
> 3. JavaScript 作为一种弱类型的语言，具有天然的多态性，**好像**压根不需要考虑类型解耦问题——目前的 JavaScript 语法里**确实不支持抽象类的直接实现**，只能凭借模拟去还原抽象类

## 一个不简单的简单工厂引发的命案

1. 上一节中，我们把 Boss 这个角色和普通员工塞进了一个工厂
   （1）Boss 和基层员工在职能上差别上还是挺大的，需要在员工系统里进行表现——需要对某一群体的对象进行单独的逻辑处理（员工绩效评估的打分入口以及其他许多操作，只有管理层可以执行）
   （2）修改 Factory 的函数体、增加管理层相关的判断和处理逻辑？
   		——单从功能实现上来说，没问题
   		——但公司不仅能金只有这两类人，还有外包同学、保安，他们的权限和职能都存在着质的差别：因此，如果每考虑到一个新的员工群体，就回去修改一次 Factory 的函数体，这样做就糟糕透了

> 1. 首先，Factory 会变得异常庞大——庞大到每次添加的时候都不敢下手，生怕自己万一写出一个 Bug，就会导致 Factory 的崩坏，进而摧毁整个系统
> 2. 其次，坑死了你的队友——Factory 的逻辑过于繁杂和混乱，没人敢维护它
> 3. 最后，还连带坑了测试同学——每次新加一个工种，都不得不对整个 Factory 的逻辑进行回归（因为新加工种这个改变你是在 Factory 内部原地发生的）
>
> **这一切悲剧的根源只有一个——没有遵守开放封闭原则**

> 开放封闭原则：对拓展开放，对修改封闭——即软件实体（类、模块、函数）可以扩展，但是不可修改——**修改 Factory 函数体的操作实际上就是在修改，而不是在扩展**

## 抽象工厂模式

1. 智能手机的基本组成 = 操作系统（Operating System，OS）+ 硬件（HardWare）

2. 工厂必须既准备好了操作系统，也准备好了硬件，才能实现手机的量产——操作系统和硬件背后存在不同的厂商，但现在**并不知道下一个生产线到底具体想生产一台什么样的手机**，只知道手机必须有这两部分组成，所以先用一个**抽象类**来约定住这台手机的基本组成：

   ```js
   class MobilePhoneFactory {
       // 提供操作系统的接口
       createOS() {
           throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！")
       }
       // 提供硬件的接口
       createHardWare() {
           throw new Error("抽象工厂方法不允许直接调用，你需要将我重写！")
       }
   }
   ```

3. **抽象工厂（AbstractFactory）不干活，具体工厂（ConcreteFactory）来干活！**——当明确了生产方案，明确某一条手机生产流水线具体要生产什么样的手机之后，就可以**化抽象为具体**

4. 想要一个专门生产 Android 系统 + 高通硬件的手机的生产线，给这类手机型号起名叫 FakeStar：

   ```js
   class FakeStarFactory extends MobilePhoneFactory {
       createOS() {
           // 提供安卓系统实例
           return new AndroidOS()
       }
       createHardWare() {
           // 提供高通硬件实例
           return new QualcommHardWare()
       }
   }
   ```


5. **具体产品（ConcreteProduct）类**：AndroidOS 和 QualcommHardwate 分别用于生成具体的操作系统和硬件实例，他们都是 **用于 new 出具体对象的类**，叫做具体产品类
   ——具体产品类往往不会孤立存在
   ——不同的具体产品类往往有着共同的功能，比如安卓系统类和苹果系统类，它们都是操作系统，都有着可以**操控手机硬件系统**这样一个最基本的功能——因此我们可以用一个**抽象产品（AbstractProduct）类**来声明这一类产品应该具有的基本功能

   ```js
   // 定义操作系统这类产品的抽象产品类
   class OS {
       controlHardware() {
           throw new Error('抽象产品方法不允许直接调用，你需要将我重写！')
       }
   }
   
   // 定义具体操作系统的具体产品类
   class AndroidOS extends OS {
   	controlHardware() {
           console.log('我会用安卓的方式去操作硬件')
       }
   }
   
   class AppleOS extends OS {
       controlHardware() {
           console.log('我会用苹果的方式去操作硬件')
       }
   }
   ```

   ```js
   // 定义手机硬件这类产品的抽象产品类
   class HardWare {
       // 手机硬件的共性方法，这里提取了“根据命令运转”这个共性
       operateByOrder() {
           throw new Error('抽象产品方法不允许直接调用，你需要将我重写！');
       }
   }
   
   // 定义具体硬件的具体产品类
   class QualcommHardWare extends HardWare {
       operateByOrder() {
           console.log('我会用高通的方式去运转')
       }
   }
   
   class MiWare extends HardWare {
       operateByOrder() {
           console.log('我会用小米的方式去运转')
       }
   }
   ```

6. 需要生产一台 FakeStar 手机时：

   ```js
   // 这是我的手机
   const myPhone = new FakeStarFactory()
   
   // 让它拥有操作系统
   const myOS = myPhone.createOS()
   
   // 让它拥有硬件
   const myHardware = myPhone.createHardware()
   
   // 启动操作系统——以安卓的方式操作硬件
   myOS.controlHardware()、
   
   // 唤醒硬件——以高通的方式运转
   myHardware.operaeByOrder()
   ```

7. 理论上，我们可以实现任意操作系统和硬件的组合，以生产出一部手机：

   ```js
   class AnyStarFactory extends MobilePhoneFactory {
       createOS() {
           // 操作系统实现代码
       }
       createHardware() {
           // 硬件实现代码
       }
   }
   ```

   而且，如此操作，**对原有的系统MobilePhoneFactory不会造成任何潜在影响**，我们只需要拓展它的种类即可——所谓的“对拓展开放，对修改封闭”就这么圆满实现了——这也是之前要实现抽象产品类的意义所在

## 总结

1. 简单工厂  VS  抽象工厂
   （1）共同点：都尝试去分离一个系统中变与不变的部分
   （2）不同点：在于场景的复杂度
   		——简单工厂的使用场景：处理的对象是类，并且是一些非常好对付的类（其共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性）
   		——抽象工厂的使用场景：处理的对象也是类，但是是一些非常棘手、繁杂的类（其不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性）
2. 抽象工厂所处理的类的繁杂性，使得我们必须对**共性**作更特别的处理、**使用抽象类去降低扩展的成本**，同时需要**对类的性质作划分**，于是有了这样的四个关键角色：
   - **抽象工厂**（抽象类，用于声明最终目标产品的共性，不能被用于生成具体实例）：在一个系统里，抽象工厂可以有多个，每一个抽象工厂对应的这一类的产品，被称为“产品族”（除了手机抽象类，还可以有平板、游戏机抽象类等等）
   - **具体工厂**（用于生成产品族里的一个具体的产品）：继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类
   - **抽象产品**（抽象类，不能被用于生成具体实例）：**具体工厂**里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的**抽象产品类**
   - 具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）：比如上文中具体的一种操作系统、或具体的一种硬件

## 最后谈谈学习

1. 只会写 JavaScript、只理解 JavaScript、只通过 JavaScript 去理解软件世界是一件可怕的事情，**这会窄化你的技术视野**——因为 JavaScript 只是编程语言的一个分支，准确地说，JavaScript 是一个后辈
2. 对于服务端/客户端出身、或者单纯对受试者知识广度有疯狂执念的面试官来说，**不知道抽象工厂就像不知道 `this` 一样恐怖**
3. 设计模式的“术”说到底是在佐证它的“道”——**充分理解了设计原则后，设计模式有 1w 中也不用怕了**——抽象工厂是佐证“开放封闭原则”的良好素材